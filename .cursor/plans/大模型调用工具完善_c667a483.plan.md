---
name: 大模型调用工具完善
overview: JoyTrunk 已具备「请求带 tools → 解析 tool_calls → 执行工具 → 结果回写 messages」的完整循环；本计划通过补齐 API 约定与健壮性（tool_choice、空 content 处理、arguments 解析）、system 提示与测试，以及新增 web_search、edit_file 两类工具，确保 agent 能稳定地调用工具解决实际问题。
todos: []
isProject: false
---

# 大模型调用工具完善计划

## 现状结论

JoyTrunk 已实现与 nanobot 一致的工具调用主流程：

- **[loop.py](cli/joytrunk/agent/loop.py)**：每轮 `provider.chat(messages, tools=get_definitions())`，若 `response.has_tool_calls` 则 `add_assistant_message` + 对每个 `tool_call` 执行 `tools_reg.execute(name, arguments)` + `add_tool_result`，再循环直至无 tool_calls 或达最大轮数。
- **[provider.py](cli/joytrunk/agent/provider.py)**：`chat` / `chat_via_router` 将 `tools` 写入 body；`_parse_response` 从 `message.tool_calls` 解析出 `ToolCall(id, name, arguments)`（arguments 用 `json.loads`，失败则 `{}`）。
- **[context.py](cli/joytrunk/agent/context.py)**：`add_assistant_message` 写入带 `tool_calls` 的 assistant 消息；`add_tool_result` 写入 `role: tool` 消息。
- **工具**： [registry](cli/joytrunk/tools/registry.py) + [base](cli/joytrunk/tools/base.py) + [filesystem](cli/joytrunk/tools/filesystem.py) + [exec_tool](cli/joytrunk/tools/exec_tool.py)，`get_definitions()` 返回 OpenAI function 格式，`execute` 校验参数并返回字符串。
- **Gateway**：`/api/llm/chat/completions` 将 `req.body` 原样转发，tools / tool_calls 会透传。

缺口在于：部分厂商/模型需要显式 **tool_choice**、对 **assistant 仅含 tool_calls 时的 content** 有要求、以及 **arguments 畸形 JSON** 导致解析失败，从而出现「有工具但不调」或「调了但解析失败」的情况。下面在不大改架构的前提下补齐这些点，并增强可观测与测试。

---

## 1. Provider：请求与解析

**1.1 请求体增加 tool_choice**

- 在 [provider.py](cli/joytrunk/agent/provider.py) 的 `chat()` 和 `chat_via_router()` 中，当 `tools` 非空时，除设置 `body["tools"]` 外，增加 `body["tool_choice"] = "auto"`，以便符合 OpenAI 规范并促使模型在需要时返回 tool_calls。

**1.2 发往 API 前清洗 messages（空 content）**

- 部分 API 在 assistant 消息仅有 `tool_calls` 且 `content` 为空时报 400。参考 nanobot 的 `_sanitize_empty_content`：在 `chat()` 和 `chat_via_router()` 中，在构建 `body["messages"]` 时对消息列表做一次清洗：若 `role == "assistant"` 且存在 `tool_calls` 且 `content` 为空字符串，则将该条消息的 `content` 设为 `None`（或按厂商要求设为 `"(empty)"`，以实际兼容为准）。仅改请求体，不改变 context 中落盘格式。

**1.3 解析 tool_calls 时增强 arguments 容错**

- 在 `_parse_response()` 中，对 `function.arguments` 为字符串时，先用 `json.loads`；若 `JSONDecodeError`，再用容错解析（例如引入 **json_repair** 或简单 strip/正则修正常见畸形），得到 dict 后再构造 `ToolCall`；若仍失败则使用 `{}` 并保留该 tool_call（避免整条响应失效）。这样模型返回的轻微不规范 JSON 仍可执行。

---

## 2. 系统提示（可选但推荐）

- 在 [context.py](cli/joytrunk/agent/context.py) 的 `build_system_prompt()` 中，在合适位置（例如在 TOOLS.md 或生存法则之后）增加一两句明确说明：当前会话具备通过 function calling 提供的工具（如 read_file、write_file、list_dir、exec），在需要读取/写入文件、列出目录或执行命令时应主动调用相应工具。不枚举具体参数，避免与 API 下发的 schema 重复。
- 或仅在 [templates/TOOLS.md](cli/joytrunk/templates/TOOLS.md) 中补充一句「当你需要读文件、写文件、列目录或执行命令时，请使用系统提供的对应工具」，由 system 统一加载即可。

---

## 3. 测试与可观测

**3.1 单元/集成测试**

- **Provider**：为 `_parse_response` 增加用例：仅 `tool_calls`、无 `content`；`arguments` 为合法 JSON 字符串；`arguments` 为带尾逗号等畸形字符串（若使用 json_repair，则验证能解析为 dict）。
- **Loop**：在现有 [test_agent_loop.py](cli/tests/test_agent_loop.py) 基础上，增加或明确一条「模型先返回 tool_calls，再返回纯文本」的用例：mock 第一次返回带一个 read_file 的 tool_call，第二次返回最终回复；断言最终 content 为第二次的文本，且 session 中包含 assistant + tool + tool result 消息（或至少 `execute` 被调用且结果被写入 messages）。

**3.2 手动/E2E 验证**

- 在本地配置自有 LLM（如已配置的 MiniMax）下，对某员工发起「列出当前目录」或「读取 SOUL.md 前 100 字」等指令，确认模型会调用 list_dir / read_file，且 CLI 中能看到工具调用提示与最终回复；必要时在 loop 中保留或增加简要日志（如工具名与参数摘要），便于排查。

---

## 4. 新增工具类型（web_search、edit_file）

- **web_search**：联网搜索。参考 nanobot 的 [WebSearchTool](nanobot/agent/tools/web.py)（如 Brave Search API）；参数可为 `query`（必填）。API Key 可通过配置或环境变量注入（如 `BRAVE_API_KEY`），在 `create_default_registry` 中仅在配置存在时注册，避免无 key 时报错。
- **edit_file**：按片段编辑文件。参考 nanobot 的 [EditFileTool](nanobot/agent/tools/filesystem.py)（如 path + old_string + new_string 或行范围替换），避免模型对大文件整篇重写；需遵守与 read_file/write_file 相同的 `allowed_dir` 限制。
- 实现后：在 [tools/**init**.py](cli/joytrunk/tools/__init__.py) 的 `create_default_registry` 中注册两者；在 [templates/TOOLS.md](cli/joytrunk/templates/TOOLS.md) 或 system 提示中补充工具说明（名称与典型用途），便于模型选择。

---

## 5. 实施顺序建议

1. **Provider**：tool_choice + 空 content 清洗 + arguments 容错解析（及对应单元测试）。
2. **System 提示**：在 context 或 TOOLS.md 中补充一句工具使用说明。
3. **Loop 集成测试**：mock 两轮响应（tool_calls → 最终回复），断言执行与消息形态。
4. **本地/E2E**：用真实模型与真实员工目录做一次「必须用工具才能完成」的对话验证。
5. **新增工具类型**：在现有 read_file、write_file、list_dir、exec 基础上，增加 **web_search**（联网搜索，可配置 API Key，参考 nanobot 的 WebSearchTool）与 **edit_file**（按片段编辑文件，如指定行/范围替换，参考 nanobot 的 EditFileTool），并在 `create_default_registry` 中注册；同步更新 TOOLS.md 模板与 system 提示中的工具列举。

---

## 6. 不纳入本计划的内容

- **Gateway 端逻辑**：gateway 已透传 body，无需改 Node 代码；若未来 Router 对 tools 有特殊要求再单独调整。
- **历史/会话截断**：与「能否调用工具」正交，保持现有 MEMORY_WINDOW 即可。

按上述顺序落地后，agent 在「请求带 tools、解析 tool_calls、执行并回写」的链路上会与 nanobot 对齐并更稳健，能够通过 read_file、write_file、list_dir、exec 以及新增的 web_search、edit_file 等工具稳定地解决读文件、写文件、列目录、执行命令、联网搜索与片段编辑等实际问题。